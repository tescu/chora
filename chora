#!/usr/bin/env lua
-- chora
--   Simple terminal TUI for drawing pixel-art.
--
-- Licensed under the GNU GPLv2. See LICENSE file for details.
-- (c) 2025 tescu (negoitescu) - https://github.com/tescu/chora
-- TODO: Desenarea liniilor 

-- Variabile
BUFFER = {}
CANVAS = {60, 20}
WINDOW = {}
CURSOR = '@'
L   = {}
QUIT   = nil
INFO   = 'Welcome to chora!'
MODIF  = false
REDRAW = false
SELECT = 1
FILE   = ''

-- Functii terminal
term = {}
STTY = 'stty'

-- Tastatura
KEY_LEFT   = 68
KEY_DOWN   = 66
KEY_UP     = 65
KEY_RIGHT  = 67
KEY_DRAW   = 105 -- i
KEY_DEL    = 111 -- o
KEY_PICK   = 99  -- p
KEY_SAVE   = 115 -- s
KEY_EXPORT = 101 -- e
KEY_L   = 108 -- l
KEY_QUIT   = 113 -- q

-- ASCII escape codes
ESC = '\027['
END = ESC..'m'

-- Coordonate + istoric
C = {1, 1, 1, 1}

-- Culori
term.COL = {
	ESC..'40m '..END,
	ESC..'41m '..END,
	ESC..'42m '..END,
	ESC..'43m '..END,
	ESC..'44m '..END,
	ESC..'45m '..END,
	ESC..'46m '..END,
	ESC..'47m '..END
}
-- Pentru export
SVG = { 'black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white' }
XPM = { 'n', 'r', 'v', 'g', 'b', 'm', 't', 'a' }

-- -------
-- FUNCTII
-- -------
-- functionalitate de baza
switch = function(val)
	return function(cases)
		setmetatable(cases, cases)
		local f = cases[val]
		if f then f() end
	end
end

printf = function(...)
	io.write(...)
	io.flush()
end

term.clear = function()
	printf(ESC..'0;0H'..ESC..'2J')
end

term.move = function(x, y)
	printf(ESC..y..';'..x..'H')	
end

term.plot = function(x, y, c)
	printf(ESC..y..';'..x..'H'..c)
end

-- Intrare si cursor
term.cursor = function(mode)
	-- 1 arata cursorul, 0 il ascunde
	if mode == 0 then
		printf(ESC..'?25l')
	else
		printf(ESC..'?25h')
	end
end

getch = function()
	return string.byte(io.read(1))
end

term.getcursorpos = function()
	-- Spune terminalului sa trimita pozitia
	printf(ESC..'6n')
	local i, c = 0
	local s = ''
	-- Primeste prima parte (ESC + [)
	c = getch(); if c ~= 27 then return nil end
	c = getch(); if c ~= 91 then return nil end

	while true do
		i = i+1
		-- Raspuns prea mare/gresit
		if i > 8 then return nil end
		c = getch()
		if c == string.byte('R') then break end
		s = s..string.char(c)
	end

	local n, m = s:match("(%d+);(%d+)")
	if not n then return nil end
	
	-- Trimite raspunsul
	return tonumber(n), tonumber(m)
end

-- Schimba modul TTY folosind stty
term.tty = function(mode)
	if mode == 'raw' then
		return os.execute(STTY..' raw -echo 2> /dev/null')
	else
		return os.execute(STTY..' sane')
	end
end

term.getwindowsize = function()
	-- Salveaza coordonatele actuale
	printf(ESC..'s')
	-- Muta cursorul la margine
	term.move(999, 999)
	local h, w = term.getcursorpos()

	-- Intoarce-te la pozitia initiala
	print(ESC..'u')
	return w, h
end

-- Functii grafice
scene = {}
-- Canvas (ecranul principal)
scene.draw = function()
	term.move(1,1)
	-- Interpreteaza bufferul
	for y=1,#BUFFER do
		for x=1,#BUFFER[y] do
			term.plot(x, y, term.COL[BUFFER[y][x]])
		end
	end
end
-- Cursor
scene.cursor = function()
	-- pseudo-istoric
	-- Evitam rescrierea intregului ecran scriind peste caracterul vechi
	local old = BUFFER[C[4]][C[3]]

	term.plot(C[3], C[4], term.COL[old])
	term.plot(C[1], C[2], CURSOR)
end
-- Bara informatii
scene.info = function()
	-- Asigura-te ca nu raman informatii/caractere anterioare
	term.plot(1, CANVAS[2]+1, string.rep(' ', WINDOW[1]))
	term.plot(1, CANVAS[2]+1, FILE..' | '..C[1]..'/'..C[2]..' '..CANVAS[1]..'x'..CANVAS[2]..' | c: '..term.COL[SELECT]..' | '..INFO)
end

-- Memorie
-- Genereaza bufferul
buff = {}
buff.gen = function()
	local bf = {}
	for y=1, CANVAS[2] do
		local line = {}
		for x=1, CANVAS[1] do
			-- O panza noua are doar alb
			line[x] = 8
		end
		bf[y] = line
	end
	return bf
end
-- Salveaza intr-un fisier
buff.save = function()
	local f, err = io.open(FILE, 'w')
	-- Asigura ca fisierul poate fi scris
	if not f then
		INFO = 'File not saved: '..err
		return false
	end
	-- Scrie marimea panzei
	-- Este verificata la citirea fisierului pentru validarea sa
	f:write(CANVAS[1]..' '..CANVAS[2]..'\n')
	for y=1,#BUFFER do
		for x=1,#BUFFER[y] do
			-- Scrie fiecare pixel/caracter separat de spatii
			f:write(BUFFER[y][x]..' ')
		end
		-- Linie noua
		f:write('\n')
	end
	return true
end
-- Exporta intr-un fisier
buff.export = function(format)
	if format == 'svg' then
		-- Deschide un fisier nou
		local f, err = io.open(FILE..'.'..format, 'w')
		-- Verifica erorile de scriere
		if not f then
			INFO = 'File not exported: '..err
			return false
		end

		-- Prima parte
		-- Formatul SVG foloseste patratele de 10 pixeli
		f:write('<svg width="'..(CANVAS[1]*10)..'" height="'..(CANVAS[2]*10)..'" xmlns="http://www.w3.org/2000/svg">\n')
		for y=1,#BUFFER do
			for x=1,#BUFFER[y] do
				f:write('<rect x="'..((x-1)*10)..'" y="'..((y-1)*10)..'" width="10" height="10" fill="'..SVG[BUFFER[y][x]]..'" />\n')
			end
		end
		-- Inchide fisierul
		f:write('</svg>')
		f:close()
		INFO = 'SVG exported.'
	elseif format == 'xpm' then
		local f, err = io.open(FILE..'.'..format, 'w')
		if not f then
			INFO = 'File not exported: '..err
			return false
		end
		-- Format XPM3
		f:write('/* XPM */\nstatic char * XFACE[] = {\n')
		-- X, Y, număr culori, un pixel per caracter
		f:write('\t"'..CANVAS[1]..' '..CANVAS[2]..' 8 1",\n')
		-- Lista culori
		f:write('\t"a c #ffffff",\n') -- alb
		f:write('\t"n c #000000",\n') -- negru
		f:write('\t"r c #ff0000",\n') -- roșu
		f:write('\t"v c #00ff00",\n') -- verde
		f:write('\t"b c #0000ff",\n') -- bleu (albastru)
		f:write('\t"g c #ffff00",\n') -- galben
		f:write('\t"t c #00ffff",\n') -- turcoaz
		f:write('\t"m c #ff00ff",\n') -- mov/magenta
		
		for y=1,#BUFFER do
			-- inceput ('"...')
			f:write('\t"')
			for x=1,#BUFFER[y] do
				f:write(XPM[BUFFER[y][x]])
			end
			-- final ('..."')
			f:write('",\n')
		end
		-- Inchide fisierul
		f:write('}\n')
		f:close()
		INFO = 'XPM exported.'
	end
	return true
end
-- Citeste bufferul dintr-un fisier salvat
buff.read = function(filename)
	local f = io.open(filename, 'r')
	if not f then
		-- TODO: Se poate vedea acest mesaj?
		INFO = 'Cannot read file.'
		return false
	end

	-- Citeste si interpreteaza intr-o lista Lua
	local list = {}
	for line in f:lines() do
		table.insert(list, line)
	end
	f:close()

	-- Numara tokenurile
	local b = {}
	for i=1, #list do
		-- tokens
		local toks = {}
		-- '%S+': orice string
		for token in string.gmatch(list[i], '%S+') do
			table.insert(toks, tonumber(token))
		end
		table.insert(b, toks)
	end

	-- Verifica validitatea fisierului
	-- Ne asiguram ca marimea declarata in antet coincide cu cea adevarata
	if #b[#b] == b[1][1] and (#b-1) == b[1][2] then
		-- Seteaza marimea panzei
		CANVAS[1] = b[1][1]
		CANVAS[2] = b[1][2]
		local buff = {}
		for i=2,#b do
			table.insert(buff, b[i])
		end
		return buff
	else
		INFO = 'File could not be read!'
		return false
	end
end

-- MAIN
-- Trei argument: fisier nou cu nume, x, y
if #arg > 2 then
	FILE = arg[1]
	CANVAS[1] = tonumber(arg[2])
	CANVAS[2] = tonumber(arg[3])
	BUFFER = buff.gen()
-- Un argument: deschide un fisier
elseif #arg == 1 then
	FILE = arg[1]
	BUFFER = buff.read(FILE)
	if not BUFFER then
		print(arg[0]..': Invalid file format: '..INFO)
		os.exit(1)
	end
-- Niciun argument: Fisier nou gol
else
	FILE = 'default.ch'
	BUFFER = buff.gen()
end

-- Pregateste linia de comanda
term.tty('raw')
term.cursor(0)
term.clear()

-- Obtine marimea ferestrei
WINDOW[1], WINDOW[2] = term.getwindowsize()
if WINDOW[1] < CANVAS[1] or WINDOW[2] < CANVAS[2]+2 then
	-- Iesi daca ecranul este prea mic
	term.tty('sane')
	term.cursor(1)
	print(arg[0]..': Window too small. Must be at least canvas width and height+1')
	os.exit(1)
end

-- Deseneaza panza pe ecran
scene.draw()
-- Bucla principala
while not QUIT do
	-- Actualizare ecran
	if REDRAW then
		scene.draw()
		REDRAW = false
	end

	-- Deseneaza cursorul si bara de informatii
	scene.info()
	scene.cursor()
	
	local key = getch()
	INFO = key
	switch (key) {
		-- Iesire
		[KEY_QUIT] = function()
			if MODIF then
				term.clear()
				-- Intreaba utilizatorul inainte de iesire
				term.plot(1,1, 'File not saved. Save? (y/n)')
				local opt = io.read(1)
				if opt == 'y' then
					buff.save()
					QUIT = true
				elseif opt == 'n' then
					QUIT = true
				end
				term.clear()
				REDRAW = true
			else
				-- Nu a fost modificat nimic, iesi direct
				QUIT = true
			end
		end,
		-- Deplasare
		[KEY_DOWN] = function()
			C[3], C[4] = C[1], C[2]
			if C[2] < CANVAS[2] then C[2] = C[2]+1 end
		end,
		[KEY_UP] = function()
			C[3], C[4] = C[1], C[2]
			if C[2] > 1 then C[2] = C[2]-1 end
		end,
		[KEY_LEFT] = function()
			C[3], C[4] = C[1], C[2]
			if C[1] > 1 then C[1] = C[1]-1 end
		end,
		[KEY_RIGHT] = function()
			C[3], C[4] = C[1], C[2]
			if C[1] < CANVAS[1] then C[1] = C[1]+1 end
		end,
		-- Comenzi
		[KEY_PICK] = function()
			-- Alege o culoare
			term.clear()
			term.plot(1, 1, 'Choose a color (1-8):')
			-- Arata culorile disponibile
			for i=1,#term.COL do
				term.plot(4, i+1, i..' '..term.COL[i])
			end

			local col = tonumber(io.read(1))
			-- Verifica daca este in limite
			if col ~= nil then
				if col > 0 and col < 9 then
					INFO = 'Color selected.'
					SELECT = col
				end
			else
				INFO = 'Invalid number.'
			end
			REDRAW = true
			term.clear()
		end,
		[KEY_DRAW] = function()
			-- Deseneaza un pixel (caracter)
			BUFFER[C[2]][C[1]] = SELECT
			if not MODIF then MODIF = true end
		end,
		[KEY_DEL] = function()
			-- Sterge un pixel (caracter)
			BUFFER[C[2]][C[1]] = SELECT
			if not MODIF then MODIF = true end
		end,
		-- Deseneaza o linie
		[KEY_L] = function()
			if not L.a then
				-- Obtine prima valoare
				INFO = 'P1: '..C[1]..'/'..C[2]
				-- x1, y1
				L.a = {C[1], C[2]}
			else
				if L.a then
					INFO = 'P2: '..C[1]..'/'..C[2]
					-- x2, y2
					L.b = {C[1], C[2]}
					-- Bresenham (does not work / nu functioneaza)
					--local m = 2*(L.b[2]-L.a[2]) -- 2*(y2-y1)
					--local er = m-(L.b[1]-L.a[1]) -- m - (x2-x1)

					--local y = L.a[2]
					--for x=L.a[1],L.b[1] do
					--	BUFFER[y][x] = SELECT
					--	er = er+m
					--	-- Increment	
					--	if er >= 0 then
					--		y=y+1
					--		er = er-2*(L.b[1]-L.a[1])
					--	end
					--end
					-- Linii verticale si orizontale
					if L.a[1] == L.b[1] then
						-- x1 si x2 sunt identice, y difera
						local x = L.a[1]
						local ya, yb
						-- schimba ordinea in functie de directie
						if L.a[2] > L.b[2] then
							ya = L.b[2]
							yb = L.a[2]
						else
							ya = L.a[2]
							yb = L.b[2]
						end

						for y=ya,yb do
							BUFFER[y][x] = SELECT
						end
					elseif L.a[2] == L.b[2] then
						-- y1 si y2 identice, x difera
						local y = L.a[2]
						local xa, xb
						if L.a[1] > L.b[1] then
							xa = L.b[1]
							xb = L.a[1]
						else
							xa = L.a[1]
							xb = L.b[1]
						end
						for x=xa,xb do
							BUFFER[y][x] = SELECT
						end
					end
					-- Reset
					INFO = L.a[1]..','..L.a[2]..' -> '..L.b[1]..','..L.b[2]
					L.a = nil
					REDRAW = true
				end
			end
		end,
		-- Salveaza
		[KEY_SAVE] = function()
			if buff.save() then
				if MODIF then MODIF = false end
				INFO = 'File saved.'
			end
		end,
		-- Export
		[KEY_EXPORT] = function()
			term.clear()
			term.plot(1, 1, 'Press 1 for SVG, 2 for X PixMap:')

			local opt = tonumber(io.read(1))
			if opt ~= nil then
				if opt == 1 then
					buff.export('svg')
				elseif opt == 2 then
					buff.export('xpm')
				end
			end
			REDRAW = true
			term.clear()
		end,
		-- Default
		--__index = function() end
	}
end

-- La iesire, intoarce-te la normal
term.tty('sane')
term.cursor(1)
term.clear()

print('Bye bye!')
